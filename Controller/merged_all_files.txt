
=== File: /c/Users/User/Documents/Balance_Rover/Controller/balance_rover.xml ===
<mujoco model="balance_rover">
  <compiler inertiafromgeom="true"/>

  <default>
    <joint   armature="0" damping="1"/>
    <geom    friction="1 0.1 0.1"/>
    <motor   ctrlrange="-5 5"/>
  </default>

  <option gravity="0 0 -9.81" integrator="RK4" timestep="0.0005"/>

  <worldbody>
    <!-- floor plane -->
    <geom type="plane" pos="0 0 0" size="5 5 0.1"
          contype="1" conaffinity="1"
          friction="1 0.1 0.1"
          rgba="0.8 0.8 0.8 1"/>

    <body name="base" pos="0 0 0.02">
      <joint name="slide" type="slide" axis="1 0 0" range="-5 5"/>
      <inertial pos="0 0 0" mass="1.0" diaginertia="0.001 0.001 0.001"/>

      <!-- Left wheel -->
      <body name="wheel_L" pos="0  0.05 0.02">
        <joint name="L_spin" type="hinge" axis="0 1 0" limited="false"/>
        <inertial pos="0 0 0" mass="0.3" diaginertia="0.0001 0.0001 0.0001"/>
        <geom  type="cylinder"
               size="0.06 0.005"
               quat="0.7071 0.7071 0 0"
               contype="1" conaffinity="1"
               friction="1 0.1 0.1"
               rgba="0.2 0.2 0.2 1"/>
      </body>

      <!-- Right wheel -->
      <body name="wheel_R" pos="0 -0.05 0.02">
        <joint name="R_spin" type="hinge" axis="0 1 0" limited="false"/>
        <inertial pos="0 0 0" mass="0.3" diaginertia="0.0001 0.0001 0.0001"/>
        <geom  type="cylinder"
               size="0.06 0.005"
               quat="0.7071 0.7071 0 0"
               contype="1" conaffinity="1"
               friction="1 0.1 0.1"
               rgba="0.2 0.2 0.2 1"/>
      </body>

      <!-- Pendulum pole -->
      <body name="pole" pos="0 0 0.04">
        <joint name="hinge" type="hinge" axis="0 1 0" damping="0.0" limited="false"/>
        <geom type="capsule"
              fromto="0 0 0  0 0 0.5"
              size="0.02"
              rgba="0.8 0.3 0.3 1"/>
      </body>

    </body> <!-- Missing closing tag for base added here -->
  </worldbody>

  <actuator>
    <!-- Two independent wheel motors -->
    <motor joint="L_spin" name="u_L" ctrlrange="-3 3" gear="100"/>
    <motor joint="R_spin" name="u_R" ctrlrange="-3 3" gear="100"/>
  </actuator>
</mujoco>

--------------------------------------

=== File: /c/Users/User/Documents/Balance_Rover/Controller/balance_rover_env.py ===
#!/usr/bin/env python3
"""
BalanceRoverEnv: environment setup, UI, and simulation loop.
Delegates all control logic to the C++ controller library via ctypes.
Mirrors the Python env file exactly, calling on_fwd_press/release and on_bwd_press/release,
using update_controller, and exposing all live-tunable parameters.
"""

import sys, os
from pathlib import Path
import numpy as np
import mujoco, mujoco.viewer
import tkinter as tk
from ctypes import CDLL, c_void_p, c_float, c_bool

# Load & bind C++ controller DLL
dll_path = Path(__file__).parent / "controller_lib.dll"
if not dll_path.exists():
    print(f"Error: controller_lib.dll not found at {dll_path}")
    sys.exit(1)
# Ensure DLL search paths
mujoco_lib = os.getenv('MUJOCO_LIB', r'C:\mujoco\mujoco210\bin')
mingw_bin  = r'C:\msys64\mingw64\bin'
if hasattr(os, 'add_dll_directory'):
    os.add_dll_directory(str(dll_path.parent))
    if os.path.isdir(mujoco_lib): os.add_dll_directory(mujoco_lib)
    if os.path.isdir(mingw_bin):  os.add_dll_directory(mingw_bin)
else:
    os.environ['PATH'] = os.pathsep.join([
        str(dll_path.parent), mujoco_lib, mingw_bin,
        os.environ.get('PATH','')
    ])

lib = CDLL(str(dll_path))
# Controller lifecycle
lib.make_controller.argtypes    = [c_float]
lib.make_controller.restype     = c_void_p
lib.free_controller.argtypes    = [c_void_p]
lib.free_controller.restype     = None
# Manual-drive C++ bindings
for fn in ['on_fwd_press','on_fwd_release','on_bwd_press','on_bwd_release']:
    f = getattr(lib, fn)
    f.argtypes = [c_void_p]
    f.restype  = None

# Live-tunable C++ parameters (name, min, max, default)
cpp_params = [
    ('Kp_ang',   0.0, 100.0, 15.0),    # lower outer-loop P gain
    ('Ki_ang',   0.0, 50.0,   5.0),     # lower outer-loop I gain
    ('Kd_ang',   0.0, 5.0,    0.25),    # lower outer-loop D gain
    ('Kp_vel',   0.0, 50.0,  10.0),    # lower inner-loop P gain
    ('Ki_vel',   0.0, 10.0,   0.25),   # lower inner-loop I gain
    ('Kd_vel',   0.0, 1.0,    0.05),   # lower inner-loop D gain
    ('DRIVE_GAIN',      0.0, 1.0, 0.1),     # reduced manual torque
    ('DRIVE_RAMP_RATE', 0.0, 1.0, 0.05),    # slower ramp rate
    ('SMOOTH_TAU',      0.1, 20.0, 10.0),   # increased smoothing time constant
    ('OVERSHOOT_RATE',  0.0, 1.0, 0.01),    # slower manual decay
    ('DEAD_BAND',       0.0, 0.5, 0.5*(np.pi/180)),  # slightly larger dead-band
    ('DERIV_TAU',       0.0, 1.0, 0.04),   # slower derivative filter
    ('OVERSHOOT_BIAS',  0.0, 1.0, 0.02),   # smaller bias
    ('DRIFT_GAIN',     -2.0, 2.0, -0.1),   # gentler drift correction
]

# Parameter setters generated in C++: bind them
for name, mn, mx, init in cpp_params:
    fn = getattr(lib, f'set_{name}', None)
    if fn:
        fn.argtypes = [c_float]
        fn.restype  = None
# PID update binding
lib.update_controller.argtypes = [c_void_p, c_float, c_float, c_float, c_float]
lib.update_controller.restype  = c_float

# Global simulation parameters
globals_params = {
    'INITIAL_ANGLE': 10.0,
    'FALL_THRESH':   np.pi * 0.9,
    'DRIFT_WINDOW':  5.0,
    'DRIFT_GAIN':    -0.4,
    'DRIVE_RAMP_RATE': 0.2,
}

def clamp(val, lo, hi): return max(lo, min(hi, val))

class BalanceRoverEnv:
    def __init__(self):
        xml = Path(__file__).with_name('balance_rover.xml')
        if not xml.exists(): sys.exit('Error: balance_rover.xml not found')

        # Load Mujoco model
        self.model = mujoco.MjModel.from_xml_path(str(xml))
        self.data  = mujoco.MjData(self.model)
        self.dt    = self.model.opt.timestep

        # C++ controller
        self.ctrl = lib.make_controller(c_float(self.dt))

        # Joint indices
        hinge_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_JOINT, 'hinge')
        slide_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_JOINT, 'slide')
        self.hinge = self.model.jnt_qposadr[hinge_id]
        self.slide = self.model.jnt_qposadr[slide_id]

        # State
        self.drive_target  = 0.0
        self.drive_current = 0.0
        self.manual_active = False
        self.buf           = []

        # Viewer & UI
        self.viewer = mujoco.viewer.launch_passive(
            self.model, self.data, key_callback=self._noop
        )
        self._init_ui()
        self.respawn()

    def _init_ui(self):
        self.root = tk.Tk()
        self.root.title('Rover Control & Parameters')

        # Forward/Backward buttons
        btn_f = tk.Button(self.root, text='Forward',  width=10)
        btn_b = tk.Button(self.root, text='Backward', width=10)
        btn_f.grid(row=0, column=0, padx=5, pady=5)
        btn_b.grid(row=0, column=1, padx=5, pady=5)
        btn_f.bind('<ButtonPress-1>',  lambda e: lib.on_fwd_press(self.ctrl))
        btn_f.bind('<ButtonRelease-1>',lambda e: lib.on_fwd_release(self.ctrl))
        btn_b.bind('<ButtonPress-1>',  lambda e: lib.on_bwd_press(self.ctrl))
        btn_b.bind('<ButtonRelease-1>',lambda e: lib.on_bwd_release(self.ctrl))

        # Status label
        self.lbl = tk.Label(
            self.root,
            text='Angle = 0.00Â°, Drift = 0.0000 m/s',
            width=40
        )
        self.lbl.grid(row=1, column=0, columnspan=2, pady=(0,10))

        # Sliders for C++ parameters
        for i, (name, mn, mx, init) in enumerate(cpp_params, start=2):
            scale = tk.Scale(
                self.root,
                label=name,
                from_=mn,
                to=mx,
                resolution=(mx - mn) / 100 if mx > mn else mn / 100,
                orient=tk.HORIZONTAL,
                command=lambda v, n=name: getattr(lib, f'set_{n}')(c_float(float(v)))
            )
            scale.set(init)
            scale.grid(row=i, column=0, columnspan=2, sticky='we', padx=5)

        # Global parameter entries
        row = 2 + len(cpp_params)
        self.entries = {}
        for key in globals_params:
            tk.Label(self.root, text=f'{key}:').grid(row=row, column=0, sticky='e')
            e = tk.Entry(self.root, width=8)
            e.insert(0, str(globals_params[key]))
            e.grid(row=row, column=1, sticky='w')
            self.entries[key] = e
            row += 1

        tk.Button(
            self.root,
            text='Update Globals',
            command=self._update_globals
        ).grid(row=row, column=0, columnspan=2, pady=5)
        tk.Button(
            self.root,
            text='Respawn',
            command=self.respawn
        ).grid(row=row+1, column=0, columnspan=2, pady=(0,10))

    def _update_globals(self):
        for key, entry in self.entries.items():
            try:
                globals_params[key] = float(entry.get())
            except ValueError:
                pass
        print('Updated globals:', globals_params)

    def _noop(self, *args):
        # disable keyboard control
        pass

    def respawn(self):
        mujoco.mj_resetData(self.model, self.data)
        self.data.qpos[:] = 0.0
        self.data.qvel[:] = 0.0
        self.data.qpos[self.hinge] = np.deg2rad(globals_params['INITIAL_ANGLE'])
        mujoco.mj_forward(self.model, self.data)
        self.drive_current = 0.0
        self.buf.clear()

    def run(self):
        try:
            while True:
                mujoco.mj_step(self.model, self.data)

                # Drift correction
                v = float(self.data.qvel[self.slide])
                self.buf.append(v)
                if len(self.buf) > int(globals_params['DRIFT_WINDOW'] / self.dt):
                    self.buf.pop(0)
                drift = sum(self.buf) / len(self.buf)
                if not self.manual_active:
                    self.drive_target = -drift * globals_params['DRIFT_GAIN']

                # Manual ramp
                err = self.drive_target - self.drive_current
                d = globals_params['DRIVE_RAMP_RATE'] * self.dt
                if err > d:
                    self.drive_current += d
                elif err < -d:
                    self.drive_current -= d
                else:
                    self.drive_current = self.drive_target

                # Call C++ PID
                theta = float(self.data.qpos[self.hinge])
                thetad = float(self.data.qvel[self.hinge])
                cmd = lib.update_controller(
                    self.ctrl,
                    c_float(theta),
                    c_float(thetad),
                    c_float(drift),
                    c_float(self.dt)
                )

                # Apply and update UI
                self.data.ctrl[0] = cmd
                self.data.ctrl[1] = cmd
                self.lbl.config(
                    text=f"Angle = {np.degrees(theta):.2f}Â°, Drift = {drift:.4f} m/s"
                )
                self.viewer.sync()
                self.root.update()
        except tk.TclError:
            # window closed
            pass
        finally:
            lib.free_controller(self.ctrl)
            print("Simulation terminated by user.")

if __name__ == '__main__':
    BalanceRoverEnv().run()

--------------------------------------

=== File: /c/Users/User/Documents/Balance_Rover/Controller/controller_lib.cpp ===
#include <cmath>
#include <deque>

extern "C" {

// âââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
// Direct port of Python pid_controller.py logic
// âââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

// INITIAL TUNING PARAMETERS (live-tunable via setters)
static float Kp_ang       = 30.0f;
static float Ki_ang       = 10.0f;
static float Kd_ang       = 0.5f;
static float Kp_vel       = 20.0f;
static float Ki_vel       = 0.5f;
static float Kd_vel       = 0.1f;

static float DRIVE_GAIN      = 0.4f;    // NÂ·m per button/key press
static float DRIVE_RAMP_RATE = 0.2f;    // NÂ·m per second
static float SMOOTH_TAU      = 4.0f;    // seconds for exp smoothing
static float OVERSHOOT_RATE  = 0.05f;   // manual drive decay (NÂ·m per sec)

static float FALL_THRESH     = 3.14159265358979323846f * 0.9f;
static float DEAD_BAND       = 0.1f * (3.14159265358979323846f/180.0f);
static float DERIV_TAU       = 0.02f;
static float OVERSHOOT_BIAS  = 0.10f;
static float DRIFT_WINDOW    = 5.0f;
static float DRIFT_GAIN      = -0.4f;
// âââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

// Setter functions for live tuning
#define DECL_SET(name) void set_##name(float v) { name = v; }
DECL_SET(Kp_ang)       DECL_SET(Ki_ang)       DECL_SET(Kd_ang)
DECL_SET(Kp_vel)       DECL_SET(Ki_vel)       DECL_SET(Kd_vel)
DECL_SET(DRIVE_GAIN)   DECL_SET(DRIVE_RAMP_RATE) DECL_SET(SMOOTH_TAU)
DECL_SET(OVERSHOOT_RATE) DECL_SET(DEAD_BAND)    DECL_SET(DERIV_TAU)
DECL_SET(OVERSHOOT_BIAS) DECL_SET(DRIFT_GAIN)   // FALL_THRESH, DRIFT_WINDOW not live-tuned

// DualPID struct
struct DualPID {
    float Kp, Ki, Kd;
    float integral = 0.0f;
    float prev_error = 0.0f;
    float d_filtered = 0.0f;
    DualPID(float p, float i, float d) : Kp(p), Ki(i), Kd(d) {}
    void reset() { integral = prev_error = d_filtered = 0.0f; }
    float update(float error, float dt, float output, float lo, float hi) {
        // dead-band
        if (std::fabs(error) >= DEAD_BAND) {
            float d_raw = (error - prev_error) / dt;
            float alpha = dt / (DERIV_TAU + dt);
            d_filtered += alpha * (d_raw - d_filtered);
        }
        // anti-windup
        if (output > lo && output < hi) integral += error * dt;
        // PID + bias
        float u = Kp * error + Ki * integral + Kd * d_filtered
                + OVERSHOOT_BIAS * std::copysign(1.0f, error);
        // clamp
        float u_sat = std::fmax(lo, std::fmin(hi, u));
        prev_error = error;
        return u_sat;
    }
};

// RoverController equivalent
struct Controller {
    DualPID angle_pid{Kp_ang, Ki_ang, Kd_ang};
    DualPID vel_pid{Kp_vel, Ki_vel, Kd_vel};

    float drive_current = 0.0f;
    float u_smoothed    = 0.0f;
    bool  manual_active = false;
    std::deque<float> drift_buf;
    size_t max_len = 0;
};

// API
void* make_controller(float dt) {
    Controller* c = new Controller();
    c->max_len = static_cast<size_t>(DRIFT_WINDOW / dt);
    return c;
}

void free_controller(void* ptr) {
    delete static_cast<Controller*>(ptr);
}

void on_fwd_press(void* ptr) {
    Controller* c = static_cast<Controller*>(ptr);
    c->manual_active = true;
    c->drive_current += DRIVE_GAIN;
}
void on_fwd_release(void* ptr) {
    static_cast<Controller*>(ptr)->manual_active = false;
}
void on_bwd_press(void* ptr) {
    Controller* c = static_cast<Controller*>(ptr);
    c->manual_active = true;
    c->drive_current -= DRIVE_GAIN;
}
void on_bwd_release(void* ptr) {
    static_cast<Controller*>(ptr)->manual_active = false;
}

float update_controller(
    void* ptr,
    float theta,
    float theta_dot,
    float slide_vel,
    float dt
) {
    Controller* c = static_cast<Controller*>(ptr);
    // drift buffer
    c->drift_buf.push_back(slide_vel);
    if (c->drift_buf.size() > c->max_len) c->drift_buf.pop_front();
    float v_avg = 0;
    for (float v : c->drift_buf) v_avg += v;
    v_avg /= c->drift_buf.size();
    // drift correction
    if (!c->manual_active) c->drive_current = -v_avg * DRIFT_GAIN;
    // manual decay
    if (c->drive_current != 0.0f) {
        float dec = OVERSHOOT_RATE * dt;
        if (std::fabs(c->drive_current) > dec)
            c->drive_current -= std::copysign(dec, c->drive_current);
        else
            c->drive_current = -std::copysign(dec - std::fabs(c->drive_current), c->drive_current);
    }
    // PID angle
    float err_ang = -theta;
    float u_ang = c->angle_pid.update(err_ang, dt, c->u_smoothed, -INFINITY, INFINITY);
    // PID vel
    float err_vel = u_ang - theta_dot;
    float u_vel = c->vel_pid.update(err_vel, dt, c->u_smoothed, -INFINITY, INFINITY);
    // target
    float u_target = u_vel + c->drive_current;
    // smoothing
    c->u_smoothed += (dt / SMOOTH_TAU) * (u_target - c->u_smoothed);
    return c->u_smoothed;
}

} // extern "C"

--------------------------------------

=== File: /c/Users/User/Documents/Balance_Rover/Controller/pid_controller.py ===
#!/usr/bin/env python3
"""
Controller logic for BalanceRover:
- Dual-loop PID (angle + velocity)
- Drift/movement handling (automatic drift correction, manual drive, smoothing)
- Anti-windup, derivative filtering, dead-band, bias, rate limits, etc.
"""

import sys
from pathlib import Path
import numpy as np
from collections import deque

# âââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
# INITIAL TUNING PARAMETERS (live-tunable via UI)
# Outer loop (angle) gains
Kp_ang, Ki_ang, Kd_ang = 30.0, 10.0, 0.5
# Inner loop (velocity) gains
Kp_vel, Ki_vel, Kd_vel = 20.0, 0.5, 0.1

DRIVE_GAIN      = 0.4    # NÂ·m per button/key press
DRIVE_RAMP_RATE = 0.2    # NÂ·m per second
SMOOTH_TAU      = 4      # seconds for exp smoothing
FALL_THRESH     = np.pi * 0.9
SIM_DURATION    = 600.0  # seconds

# Dead-band threshold (rad)
DEAD_BAND = np.deg2rad(0.1)
# Derivative filter time constant (s)
DERIV_TAU = 0.02
# Control rate limit (unit/sec) for soft-start
CMD_RATE_LIMIT = 1.0
# Overshoot bias magnitude
OVERSHOOT_BIAS = 0.10

# Drift & manual drive parameters
INITIAL_ANGLE   = 10.0    # deg for respawn routines
OVERSHOOT_RATE  = 0.05    # manual drive decay (NÂ·m per sec)
DRIFT_WINDOW    = 5.0     # seconds
DRIFT_GAIN      = -0.4    # NÂ·m per (m/s) drift
# âââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

class DualPID:
    def __init__(self, Kp, Ki, Kd):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.integral = 0.0
        self.prev_error = 0.0
        self.d_filtered = 0.0

    def reset(self):
        self.integral = 0.0
        self.prev_error = 0.0
        self.d_filtered = 0.0

    def update(self, error, measurement_dot, dt, output, output_limits):
        # Dead-band: allow small errors to pass
        if abs(error) < DEAD_BAND:
            pass

        # raw derivative
        d_raw = (error - self.prev_error) / dt if dt > 0 else 0.0
        alpha = dt / (DERIV_TAU + dt)
        self.d_filtered += alpha * (d_raw - self.d_filtered)

        # anti-windup integration
        if output_limits[0] < output < output_limits[1]:
            self.integral += error * dt

        # PID with filtered derivative
        u = self.Kp * error + self.Ki * self.integral + self.Kd * self.d_filtered
        # slight overshoot bias
        u += OVERSHOOT_BIAS * np.sign(error)
        # saturate
        u_sat = np.clip(u, output_limits[0], output_limits[1])
        self.prev_error = error
        return u_sat

class RoverController:
    def __init__(self, timestep):
        # PID for pole balance
        self.pid = DualPID(Kp_ang, Ki_ang, Kd_ang)
        # Manual & drift state
        self.drive_current = 0.0
        self.u_smoothed = 0.0
        self.manual_active = False
        # Drift buffer
        max_len = int(DRIFT_WINDOW / timestep)
        self.drift_buffer = deque(maxlen=max_len)

    def reset(self):
        # Reset controllers and state
        self.pid.reset()
        self.drive_current = 0.0
        self.u_smoothed = 0.0
        self.manual_active = False
        self.drift_buffer.clear()

    def on_fwd_press(self):
        self.manual_active = True
        self.drive_current += DRIVE_GAIN

    def on_fwd_release(self):
        self.manual_active = False

    def on_bwd_press(self):
        self.manual_active = True
        self.drive_current -= DRIVE_GAIN

    def on_bwd_release(self):
        self.manual_active = False

    def step(self, theta, theta_dot, slide_vel, dt):
        # Buffer slide velocity
        self.drift_buffer.append(slide_vel)
        v_avg = sum(self.drift_buffer) / len(self.drift_buffer)

        # Automatic drift correction
        if not self.manual_active:
            self.drive_current = -v_avg * DRIFT_GAIN

        # Manual drive decay / overshoot bounce
        if self.drive_current != 0.0:
            dec = OVERSHOOT_RATE * dt
            if abs(self.drive_current) > dec:
                self.drive_current -= np.sign(self.drive_current) * dec
            else:
                self.drive_current = -np.sign(self.drive_current) * (dec - abs(self.drive_current))

        # PID control for pole
        u_pid = self.pid.update(theta, theta_dot, dt, self.u_smoothed, (-300000, 300000))
        u_target = u_pid + self.drive_current

        # Exponential smoothing
        self.u_smoothed += (dt / SMOOTH_TAU) * (u_target - self.u_smoothed)

        # Final command
        cmd = float(np.clip(self.u_smoothed, -np.inf, np.inf))
        return cmd, v_avg

--------------------------------------
