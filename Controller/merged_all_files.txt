
=== File: /c/Users/User/Documents/Balance_Rover/Controller/balance_rover.xml ===
<mujoco model="balance_rover">
  <compiler inertiafromgeom="true"/>

  <default>
    <joint   armature="0" damping="1"/>
    <geom    friction="1 0.1 0.1"/>
    <motor   ctrlrange="-5 5"/>
  </default>

  <option gravity="0 0 -9.81" integrator="RK4" timestep="0.0005"/>

  <worldbody>
    <!-- floor plane -->
    <geom type="plane" pos="0 0 0" size="5 5 0.1"
          contype="1" conaffinity="1"
          friction="1 0.1 0.1"
          rgba="0.8 0.8 0.8 1"/>

    <body name="base" pos="0 0 0.02">
      <joint name="slide" type="slide" axis="1 0 0" range="-5 5"/>
      <inertial pos="0 0 0" mass="1.0" diaginertia="0.001 0.001 0.001"/>

      <!-- Left wheel -->
      <body name="wheel_L" pos="0  0.05 0.02">
        <joint name="L_spin" type="hinge" axis="0 1 0" limited="false"/>
        <inertial pos="0 0 0" mass="0.3" diaginertia="0.0001 0.0001 0.0001"/>
        <geom  type="cylinder"
               size="0.06 0.005"
               quat="0.7071 0.7071 0 0"
               contype="1" conaffinity="1"
               friction="1 0.1 0.1"
               rgba="0.2 0.2 0.2 1"/>
      </body>

      <!-- Right wheel -->
      <body name="wheel_R" pos="0 -0.05 0.02">
        <joint name="R_spin" type="hinge" axis="0 1 0" limited="false"/>
        <inertial pos="0 0 0" mass="0.3" diaginertia="0.0001 0.0001 0.0001"/>
        <geom  type="cylinder"
               size="0.06 0.005"
               quat="0.7071 0.7071 0 0"
               contype="1" conaffinity="1"
               friction="1 0.1 0.1"
               rgba="0.2 0.2 0.2 1"/>
      </body>

      <!-- Pendulum pole -->
      <body name="pole" pos="0 0 0.04">
        <joint name="hinge" type="hinge" axis="0 1 0"
               damping="0.05" range="-3.14 3.14"/>
        <geom  type="capsule"
               fromto="0 0 0   0 0 0.5"
               size="0.02"
               rgba="0.8 0.3 0.3 1"/>
      </body>
    </body>
  </worldbody>

  <actuator>
    <!-- Two independent wheel motors -->
    <motor joint="L_spin" name="u_L" ctrlrange="-3 3" gear="100"/>
    <motor joint="R_spin" name="u_R" ctrlrange="-3 3" gear="100"/>
  </actuator>
</mujoco>

--------------------------------------

=== File: /c/Users/User/Documents/Balance_Rover/Controller/balance_rover_env.py ===
#!/usr/bin/env python3
"""
BalanceRoverEnv with PID + keyboard & button drive + live PID tuning + respawn,
with robust button handling so subsequent presses work correctly.
"""

import sys
from pathlib import Path
import numpy as np
import mujoco
import mujoco.viewer
from mujoco.viewer import glfw
import tkinter as tk

# —————————————————————————————————————————————————————————
# INITIAL TUNING PARAMETERS (live‐tunable via UI)
Kp, Ki, Kd = 30.0, 1.0, 0.5
DRIVE_GAIN      = 0.2    # N·m per button/key press
DRIVE_RAMP_RATE = 0.2    # N·m per second
SMOOTH_TAU      = 0.5    # seconds for exponential smoothing
FALL_THRESH     = np.pi * 0.9
SIM_DURATION    = 600.0  # seconds of simulation time
# —————————————————————————————————————————————————————————

class BalanceRoverEnv:
    def __init__(self):
        xml = Path(__file__).with_name("balance_rover.xml")
        if not xml.exists():
            print("Error: balance_rover.xml not found.")
            sys.exit(1)

        # load model & data
        self.model = mujoco.MjModel.from_xml_path(str(xml))
        self.data  = mujoco.MjData(self.model)

        # PID integrator state
        self.integral      = 0.0
        self.prev_error    = 0.0

        # manual‐drive pressed flags
        self.forward_pressed  = False
        self.backward_pressed = False

        # drive targets & smoothing state
        self.drive_target  = 0.0
        self.drive_current = 0.0
        self.u_smoothed    = 0.0

        # launch MuJoCo window
        self.viewer = mujoco.viewer.launch_passive(
            self.model,
            self.data,
            key_callback=self._key_cb
        )

        # build control UI
        self._init_button_ui()

        # initial perfect respawn
        self.respawn()

    def _init_button_ui(self):
        """Create Tk window with drive buttons, ω display, PID inputs, and respawn."""
        self.root = tk.Tk()
        self.root.title("Rover Drive + PID Tuning")
        self.root.resizable(False, False)

        # Drive buttons
        btn_fwd = tk.Button(self.root, text="Forward",  width=10)
        btn_bwd = tk.Button(self.root, text="Backward", width=10)
        btn_fwd.grid(row=0, column=0, padx=5, pady=5)
        btn_bwd.grid(row=0, column=1, padx=5, pady=5)

        # Angular velocity display
        self.vel_label = tk.Label(self.root, text="ω = 0.000 rad/s", width=20)
        self.vel_label.grid(row=1, column=0, columnspan=2, pady=(0,10))

        # PID entries
        tk.Label(self.root, text="Kp:").grid(row=2, column=0, sticky="e")
        self.entry_Kp = tk.Entry(self.root, width=6)
        self.entry_Kp.insert(0, str(Kp))
        self.entry_Kp.grid(row=2, column=1, sticky="w")

        tk.Label(self.root, text="Ki:").grid(row=3, column=0, sticky="e")
        self.entry_Ki = tk.Entry(self.root, width=6)
        self.entry_Ki.insert(0, str(Ki))
        self.entry_Ki.grid(row=3, column=1, sticky="w")

        tk.Label(self.root, text="Kd:").grid(row=4, column=0, sticky="e")
        self.entry_Kd = tk.Entry(self.root, width=6)
        self.entry_Kd.insert(0, str(Kd))
        self.entry_Kd.grid(row=4, column=1, sticky="w")

        # Update PID button
        btn_update = tk.Button(self.root, text="Update PID Gains", command=self._update_pid)
        btn_update.grid(row=5, column=0, columnspan=2, pady=(5,5))

        # Respawn button
        btn_respawn = tk.Button(self.root, text="Respawn Rover", command=self.respawn)
        btn_respawn.grid(row=6, column=0, columnspan=2, pady=(5,10))

        # Bind drive button events
        btn_fwd.bind("<ButtonPress-1>",   self._on_fwd_press)
        btn_fwd.bind("<ButtonRelease-1>", self._on_fwd_release)
        btn_bwd.bind("<ButtonPress-1>",   self._on_bwd_press)
        btn_bwd.bind("<ButtonRelease-1>", self._on_bwd_release)

    def _update_pid(self):
        """Read PID entries and apply new gains."""
        global Kp, Ki, Kd
        try:
            Kp = float(self.entry_Kp.get())
            Ki = float(self.entry_Ki.get())
            Kd = float(self.entry_Kd.get())
            print(f"PID gains updated: Kp={Kp}, Ki={Ki}, Kd={Kd}")
        except ValueError:
            print("Invalid PID input! Please enter numeric values.")

    def respawn(self):
        """Reset rover to upright, stationary state with zero controls."""
        mujoco.mj_resetData(self.model, self.data)
        # zero positions, velocities, controls
        self.data.qpos[:] = 0.0
        self.data.qvel[:] = 0.0
        self.data.ctrl[:] = 0.0
        mujoco.mj_forward(self.model, self.data)
        # reset controller states
        self.integral      = 0.0
        self.prev_error    = 0.0
        self.drive_target  = 0.0
        self.drive_current = 0.0
        self.u_smoothed    = 0.0
        self.forward_pressed  = False
        self.backward_pressed = False

    def _on_fwd_press(self, event):
        self.forward_pressed = True
        self._update_drive_target()

    def _on_fwd_release(self, event):
        self.forward_pressed = False
        self._update_drive_target()

    def _on_bwd_press(self, event):
        self.backward_pressed = True
        self._update_drive_target()

    def _on_bwd_release(self, event):
        self.backward_pressed = False
        self._update_drive_target()

    def _update_drive_target(self):
        self.drive_target = DRIVE_GAIN * (1 if self.forward_pressed else 0) \
                          - DRIVE_GAIN * (1 if self.backward_pressed else 0)

    def _key_cb(self, window, key, scancode, action, mods):
        """Handle ←/→ key presses for drive."""
        if key == glfw.KEY_RIGHT:
            if action == glfw.PRESS:
                self.forward_pressed = True
                self._update_drive_target()
            elif action == glfw.RELEASE:
                self.forward_pressed = False
                self._update_drive_target()
        if key == glfw.KEY_LEFT:
            if action == glfw.PRESS:
                self.backward_pressed = True
                self._update_drive_target()
            elif action == glfw.RELEASE:
                self.backward_pressed = False
                self._update_drive_target()

    def close(self):
        self.viewer.close()
        self.root.destroy()


if __name__ == "__main__":
    env = BalanceRoverEnv()
    dt  = env.model.opt.timestep
    sim_time = 0.0

    while sim_time < SIM_DURATION:
        mujoco.mj_step(env.model, env.data)
        sim_time += dt

        if not np.all(np.isfinite(env.data.qacc)):
            print(f"Numerical instability at t={sim_time:.3f}s; aborting early.")
            break

        # read pendulum angle & angular velocity
        theta     = env.data.qpos[3]
        theta_dot = env.data.qvel[3]
        env.vel_label.config(text=f"ω = {theta_dot:.3f} rad/s")

        # ramp manual drive
        err_d  = env.drive_target - env.drive_current
        mdx    = DRIVE_RAMP_RATE * dt
        if abs(err_d) > mdx:
            env.drive_current += np.sign(err_d) * mdx
        else:
            env.drive_current = env.drive_target

        # PID on angle → torque
        err           = theta
        env.integral += err * dt
        derivative     = (err - env.prev_error) / dt
        env.prev_error = err
        u_pid          = -(Kp*err + Ki*env.integral + Kd*derivative)

        # combine & exponential‐smooth
        u_target       = u_pid + env.drive_current
        alpha          = dt / SMOOTH_TAU
        env.u_smoothed += alpha * (u_target - env.u_smoothed)

        # apply to wheels
        u   = float(np.clip(env.u_smoothed, -3.0, 3.0))
        cmd = u / 3.0
        env.data.ctrl[0] = cmd
        env.data.ctrl[1] = cmd

        # render & UI
        env.viewer.sync()
        env.root.update()

        # if it falls, just note it but keep running
        if abs(theta) > FALL_THRESH:
            print(f"Fallen at t={sim_time:.3f}s (θ={theta:.3f} rad)")

    print("Simulation time reached.")
    input("Press Enter to close…")
    env.close()

--------------------------------------

=== File: /c/Users/User/Documents/Balance_Rover/Controller/pid_controller.py ===
#!/usr/bin/env python3
"""
Simple PID controller.
Usage:
    from pid_controller import PIDController
    pid = PIDController(Kp=30.0, Ki=1.0, Kd=0.5)
    u = pid.update(error, dt)      # returns control effort (no sign inversion)
    pid.set_gains(Kp, Ki, Kd)      # update gains at runtime
    pid.reset()                    # zero integral and derivative states
"""

class PIDController:
    def __init__(self, Kp=1.0, Ki=0.0, Kd=0.0):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.integral = 0.0
        self.prev_error = 0.0

    def update(self, error, dt):
        """Compute PID output for given error and dt."""
        self.integral += error * dt
        derivative = (error - self.prev_error) / dt if dt > 0 else 0.0
        self.prev_error = error
        return (self.Kp * error) + (self.Ki * self.integral) + (self.Kd * derivative)

    def set_gains(self, Kp, Ki, Kd):
        self.Kp, self.Ki, self.Kd = Kp, Ki, Kd

    def reset(self):
        self.integral = 0.0
        self.prev_error = 0.0

--------------------------------------
