
=== File: /c/Users/User/Documents/Balance_Rover/Controller/balance_rover.xml ===
<mujoco model="balance_rover">
  <compiler inertiafromgeom="true"/>

  <default>
    <joint   armature="0" damping="1"/>
    <geom    friction="1 0.1 0.1"/>
    <motor   ctrlrange="-5 5"/>
  </default>

  <option gravity="0 0 -9.81" integrator="RK4" timestep="0.0005"/>

  <worldbody>
    <!-- floor plane -->
    <geom type="plane" pos="0 0 0" size="5 5 0.1"
          contype="1" conaffinity="1"
          friction="1 0.1 0.1"
          rgba="0.8 0.8 0.8 1"/>

    <body name="base" pos="0 0 0.02">
      <joint name="slide" type="slide" axis="1 0 0" range="-5 5"/>
      <inertial pos="0 0 0" mass="1.0" diaginertia="0.001 0.001 0.001"/>

      <!-- Left wheel -->
      <body name="wheel_L" pos="0  0.05 0.02">
        <joint name="L_spin" type="hinge" axis="0 1 0" limited="false"/>
        <inertial pos="0 0 0" mass="0.3" diaginertia="0.0001 0.0001 0.0001"/>
        <geom  type="cylinder"
               size="0.06 0.005"
               quat="0.7071 0.7071 0 0"
               contype="1" conaffinity="1"
               friction="1 0.1 0.1"
               rgba="0.2 0.2 0.2 1"/>
      </body>

      <!-- Right wheel -->
      <body name="wheel_R" pos="0 -0.05 0.02">
        <joint name="R_spin" type="hinge" axis="0 1 0" limited="false"/>
        <inertial pos="0 0 0" mass="0.3" diaginertia="0.0001 0.0001 0.0001"/>
        <geom  type="cylinder"
               size="0.06 0.005"
               quat="0.7071 0.7071 0 0"
               contype="1" conaffinity="1"
               friction="1 0.1 0.1"
               rgba="0.2 0.2 0.2 1"/>
      </body>

      <!-- Pendulum pole -->
      <body name="pole" pos="0 0 0.04">
        <joint name="hinge" type="hinge" axis="0 1 0" damping="0.0" limited="false"/>
        <geom type="capsule"
              fromto="0 0 0  0 0 0.5"
              size="0.02"
              rgba="0.8 0.3 0.3 1"/>
      </body>

    </body> <!-- Missing closing tag for base added here -->
  </worldbody>

  <actuator>
    <!-- Two independent wheel motors -->
    <motor joint="L_spin" name="u_L" ctrlrange="-3 3" gear="100"/>
    <motor joint="R_spin" name="u_R" ctrlrange="-3 3" gear="100"/>
  </actuator>
</mujoco>

--------------------------------------

=== File: /c/Users/User/Documents/Balance_Rover/Controller/balance_rover_env.py ===
#=== File: /c/Users/User/Documents/Balance_Rover/Controller/balance_rover_env.py ===
#!/usr/bin/env python3
"""
BalanceRoverEnv that delegates control logic to pid_controller.DualPID
with keyboard & button drive + live tuning of all controller parameters + respawn,
starting with the pole at 80¬∞ from the ground (10¬∞ from vertical), and displaying
the current angle relative to the vertical upward normal, and continuously applying
a corrective torque proportional to the average slide velocity (in the opposite direction)
so that the rover hovers around the same spot.
"""

import sys
from pathlib import Path
import numpy as np
import mujoco
import mujoco.viewer
from mujoco.viewer import glfw
import tkinter as tk
from collections import deque

# Import controller logic and default parameters
from pid_controller import (
    DualPID,
    Kp_ang, Ki_ang, Kd_ang,
    Kp_vel, Ki_vel, Kd_vel,
    DRIVE_GAIN, DRIVE_RAMP_RATE,
    SMOOTH_TAU, FALL_THRESH,
    SIM_DURATION
)

# Default initial pole tilt (deg)
INITIAL_ANGLE = 10.0
# Manual drive decay and overshoot rate (N¬∑m per second)
OVERSHOOT_RATE = 0.05
# Window (s) to average slide velocity
DRIFT_WINDOW = 5.0
# Proportional gain for drift correction (N¬∑m per (m/s) drift)
DRIFT_GAIN = -0.4   # tune this to your liking


class BalanceRoverEnv:
    def __init__(self):
        xml = Path(__file__).with_name("balance_rover.xml")
        if not xml.exists():
            print("Error: balance_rover.xml not found.")
            sys.exit(1)

        # Load model & data
        self.model = mujoco.MjModel.from_xml_path(str(xml))
        self.data = mujoco.MjData(self.model)

        # Joint indices
        hinge_jid = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_JOINT, 'hinge')
        slide_jid = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_JOINT, 'slide')
        self.hinge_qposadr = self.model.jnt_qposadr[hinge_jid]
        self.slide_qposadr = self.model.jnt_qposadr[slide_jid]

        # PID for pole balance
        self.pid = DualPID(Kp_ang, Ki_ang, Kd_ang)

        # Drive state
        self.drive_current = 0.0
        self.u_smoothed = 0.0
        self.manual_active = False

        # Drift buffer over last DRIFT_WINDOW seconds
        self.max_buf_len = int(DRIFT_WINDOW / self.model.opt.timestep)
        self.drift_buffer = deque(maxlen=self.max_buf_len)

        # Launch viewer & UI
        self.viewer = mujoco.viewer.launch_passive(
            self.model, self.data, key_callback=self._key_cb
        )
        self._init_button_ui()

        # Initial respawn
        self.respawn()

    def _init_button_ui(self):
        self.root = tk.Tk()
        self.root.title("Rover Control & Params")
        self.root.resizable(False, False)

        row = 0
        # Forward/back buttons
        btn_fwd = tk.Button(self.root, text="Forward", width=10)
        btn_bwd = tk.Button(self.root, text="Backward", width=10)
        btn_fwd.grid(row=row, column=0, padx=5, pady=5)
        btn_bwd.grid(row=row, column=1, padx=5, pady=5)

        # Angle & drift display
        row += 1
        self.angle_label = tk.Label(
            self.root, text="Angle = 0.00¬∞, Drift = 0.0000 m/s", width=40
        )
        self.angle_label.grid(row=row, column=0, columnspan=2, pady=(0,10))

        # Parameter entries
        param_specs = [
            ("Kp", 'Kp', 'pid'),
            ("Ki", 'Ki', 'pid'),
            ("Kd", 'Kd', 'pid'),
            ("Drive Gain", 'DRIVE_GAIN', 'global'),
            ("Drive Ramp Rate", 'DRIVE_RAMP_RATE', 'global'),
            ("Drift Window", 'DRIFT_WINDOW', 'global'),
            ("Drift Gain", 'DRIFT_GAIN', 'global'),
            ("Smooth Tau", 'SMOOTH_TAU', 'global'),
            ("Fall Threshold", 'FALL_THRESH', 'global'),
            ("Sim Duration", 'SIM_DURATION', 'global'),
        ]
        self.entries = {}
        for name, attr, scope in param_specs:
            row += 1
            tk.Label(self.root, text=f"{name}:").grid(
                row=row, column=0, sticky="e"
            )
            entry = tk.Entry(self.root, width=8)
            val = getattr(self.pid, attr) if scope == 'pid' else globals()[attr]
            entry.insert(0, str(val))
            entry.grid(row=row, column=1, sticky="w")
            self.entries[(scope, attr)] = entry

        # Update & respawn buttons
        row += 1
        tk.Button(
            self.root, text="Update Params", command=self._update_params
        ).grid(row=row, column=0, columnspan=2, pady=(5,5))
        row += 1
        tk.Button(
            self.root, text="Respawn Rover", command=self.respawn
        ).grid(row=row, column=0, columnspan=2, pady=(5,10))

        # Bind button presses/releases
        btn_fwd.bind("<ButtonPress-1>", self._on_fwd_press)
        btn_fwd.bind("<ButtonRelease-1>", self._on_fwd_release)
        btn_bwd.bind("<ButtonPress-1>", self._on_bwd_press)
        btn_bwd.bind("<ButtonRelease-1>", self._on_bwd_release)

    def _update_params(self):
        try:
            for (scope, attr), entry in self.entries.items():
                val = float(entry.get())
                if scope == 'pid':
                    setattr(self.pid, attr, val)
                else:
                    globals()[attr] = val
            print("Parameters updated.")
        except ValueError:
            print("Invalid input; please enter numeric values.")

    def respawn(self):
        mujoco.mj_resetData(self.model, self.data)
        self.data.qpos[:] = 0.0
        self.data.qvel[:] = 0.0
        self.data.ctrl[:] = 0.0
        # initial pole tilt
        self.data.qpos[self.hinge_qposadr] = np.deg2rad(INITIAL_ANGLE)
        mujoco.mj_forward(self.model, self.data)

        # reset drive & PID
        self.pid.reset()
        self.drive_current = 0.0
        self.u_smoothed = 0.0
        self.manual_active = False
        self.drift_buffer.clear()

    def _on_fwd_press(self, event):
        self.manual_active = True
        self.drive_current += DRIVE_GAIN

    def _on_fwd_release(self, event):
        self.manual_active = False

    def _on_bwd_press(self, event):
        self.manual_active = True
        self.drive_current -= DRIVE_GAIN

    def _on_bwd_release(self, event):
        self.manual_active = False

    def _key_cb(self, window, key, scancode, action, mods):
        pass  # no keyboard drive

    def run(self):
        dt = self.model.opt.timestep
        t = 0.0

        while t < SIM_DURATION:
            mujoco.mj_step(self.model, self.data)
            t += dt

            # sample and buffer slide velocity
            v = float(self.data.qvel[self.slide_qposadr])
            self.drift_buffer.append(v)
            v_avg = sum(self.drift_buffer) / len(self.drift_buffer)

            # apply continuous proportional correction opposite to avg drift
            if not self.manual_active:
                self.drive_current = -v_avg * DRIFT_GAIN

            # manual drive decay / overshoot bounce
            if self.drive_current != 0.0:
                dec = OVERSHOOT_RATE * dt
                if abs(self.drive_current) > dec:
                    self.drive_current -= np.sign(self.drive_current) * dec
                else:
                    self.drive_current = -np.sign(self.drive_current) * (dec - abs(self.drive_current))

            # combine & smooth with PID for pole
            theta = self.data.qpos[self.hinge_qposadr]
            theta_dot = self.data.qvel[self.hinge_qposadr]
            u_pid = self.pid.update(
                theta, theta_dot, dt, self.u_smoothed, (-300000,300000)
            )
            u_target = u_pid + self.drive_current
            self.u_smoothed += (dt/SMOOTH_TAU) * (u_target - self.u_smoothed)

            # apply to wheels
            cmd = float(np.clip(self.u_smoothed))
            self.data.ctrl[0] = cmd
            self.data.ctrl[1] = cmd

            # update UI
            self.angle_label.config(text=(
                f"Angle = {np.rad2deg(theta):.2f}¬∞, Drift = {v_avg:.4f} m/s"
            ))
            self.viewer.sync()
            self.root.update()

            if abs(theta) > FALL_THRESH:
                print(f"Fallen at t={t:.3f}s")

        print("Simulation complete.")
        input("Press Enter to close‚Ä¶")
        self.close()

    def close(self):
        self.viewer.close()
        self.root.destroy()


if __name__ == "__main__":
    BalanceRoverEnv().run()

--------------------------------------

=== File: /c/Users/User/Documents/Balance_Rover/Controller/pid_controller.py ===
#!/usr/bin/env python3
"""
BalanceRoverEnv with dual-loop PID + advanced control features:
1. Anti-Windup
2. Derivative Filtering
3. Reduced Dead-Band to allow small overshoot
4. Bias Term to encourage slight overshoot
5. Dead-Band/Hysteresis
7. Cascade Structure (angle‚Üívelocity‚Üítorque)
10. Soft-Start & Ramp-Limits
11. Simple Disturbance Observer
"""

import sys
from pathlib import Path
import numpy as np
import mujoco
import mujoco.viewer
from mujoco.viewer import glfw
import tkinter as tk

# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
# INITIAL TUNING PARAMETERS (live-tunable via UI)
# Outer loop (angle) gains
Kp_ang, Ki_ang, Kd_ang = 30.0, 10.0, 0.5
# Inner loop (velocity) gains
Kp_vel, Ki_vel, Kd_vel = 20.0, 0.5, 0.1

DRIVE_GAIN      = 0.4    # N¬∑m per button/key press
DRIVE_RAMP_RATE = 0.2    # N¬∑m per second
SMOOTH_TAU      = 4    # seconds for exp smoothing
FALL_THRESH     = np.pi * 0.9
SIM_DURATION    = 600.0  # seconds

# Dead-band threshold (rad) ‚Äî reduced to allow small overshoot
DEAD_BAND = np.deg2rad(0.1)
# Derivative filter time constant (s)
DERIV_TAU = 0.02
# Control rate limit (unit/sec) for soft-start
CMD_RATE_LIMIT = 1.0
# Overshoot bias magnitude
OVERSHOOT_BIAS = 0.10
# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

class DualPID:
    def __init__(self, Kp, Ki, Kd):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.integral = 0.0
        self.prev_error = 0.0
        self.d_filtered = 0.0

    def reset(self):
        self.integral = 0.0
        self.prev_error = 0.0
        self.d_filtered = 0.0

    def update(self, error, measurement_dot, dt, output, output_limits):
        # Dead-band: only clamp out extremely tiny errors
        if abs(error) < DEAD_BAND:
            # allow pass-through for small errors to create overshoot
            pass

        # Integral with anti-windup: only integrate if not saturated
        u_unsat = self.Kp * error + self.Ki * self.integral + self.Kd * ((error - self.prev_error) / dt)
        # derivative raw
        d_raw = (error - self.prev_error) / dt if dt > 0 else 0.0
        # derivative filtering
        alpha = dt / (DERIV_TAU + dt)
        self.d_filtered += alpha * (d_raw - self.d_filtered)
        # anti-windup: conditional integration
        if output_limits[0] < output < output_limits[1]:
            self.integral += error * dt
        # PID calculation with filtered derivative
        u = self.Kp * error + self.Ki * self.integral + self.Kd * self.d_filtered
        # optional slight bias for overshoot
        u += OVERSHOOT_BIAS * np.sign(error)
        # saturate
        u_sat = np.clip(u, output_limits[0], output_limits[1])
        self.prev_error = error
        return u_sat


class BalanceRoverEnv:
    def __init__(self):
        xml = Path(__file__).with_name("balance_rover.xml")
        if not xml.exists():
            print("Error: balance_rover.xml not found.")
            sys.exit(1)

        self.model = mujoco.MjModel.from_xml_path(str(xml))
        self.data  = mujoco.MjData(self.model)

        # Dual PID controllers
        self.pid_ang = DualPID(Kp_ang, Ki_ang, Kd_ang)
        self.pid_vel = DualPID(Kp_vel, Ki_vel, Kd_vel)
        # disturbance estimate
        self.dist_est = 0.0

        # manual drive
        self.forward_pressed  = False
        self.backward_pressed = False
        self.drive_target     = 0.0
        self.drive_current    = 0.0
        self.u_smoothed       = 0.0
        self.wheels_enabled   = True

        self.viewer = mujoco.viewer.launch_passive(
            self.model, self.data, key_callback=self._key_cb
        )
        self._init_button_ui()
        self.respawn()

    def _init_button_ui(self):
        self.root = tk.Tk()
        self.root.title("Dual-Loop Rover Control")
        self.root.resizable(False, False)

        # Forward/back buttons
        btn_fwd = tk.Button(self.root, text="Forward",  width=10)
        btn_bwd = tk.Button(self.root, text="Backward", width=10)
        btn_fwd.grid(row=0, column=0, padx=5, pady=5)
        btn_bwd.grid(row=0, column=1, padx=5, pady=5)

        # Angle display
        self.angle_label = tk.Label(self.root, text="Angle = 0.00¬∞", width=20)
        self.angle_label.grid(row=1, column=0, columnspan=2, pady=(0,10))

        # Toggle wheels
        self.btn_toggle = tk.Button(self.root, text="Stop Wheels", width=12,
                                    command=self._toggle_wheels)
        self.btn_toggle.grid(row=2, column=0, columnspan=2, pady=(5,10))

        btn_fwd.bind("<ButtonPress-1>",   self._on_fwd_press)
        btn_fwd.bind("<ButtonRelease-1>", self._on_fwd_release)
        btn_bwd.bind("<ButtonPress-1>",   self._on_bwd_press)
        btn_bwd.bind("<ButtonRelease-1>", self._on_bwd_release)

    def _toggle_wheels(self):
        self.wheels_enabled = not self.wheels_enabled
        self.btn_toggle.config(text="Stop Wheels" if self.wheels_enabled else "Start Wheels")
        if not self.wheels_enabled:
            self.drive_target = 0.0
            self.drive_current = 0.0

    def respawn(self):
        mujoco.mj_resetData(self.model, self.data)
        self.data.qpos[:] = 0.0
        self.data.qvel[:] = 0.0
        self.data.ctrl[:] = 0.0
        self.data.qpos[3] = np.deg2rad(10.0)
        mujoco.mj_forward(self.model, self.data)

        # reset controllers and states
        self.pid_ang.reset(); self.pid_vel.reset()
        self.dist_est = 0.0
        self.drive_target = 0.0
        self.drive_current = 0.0
        self.u_smoothed = 0.0
        self.forward_pressed = False; self.backward_pressed = False

    def _on_fwd_press(self, event):
        self.forward_pressed = True; self._update_drive_target()
    def _on_fwd_release(self, event):
        self.forward_pressed = False; self._update_drive_target()
    def _on_bwd_press(self, event):
        self.backward_pressed = True; self._update_drive_target()
    def _on_bwd_release(self, event):
        self.backward_pressed = False; self._update_drive_target()

    def _update_drive_target(self):
        if not self.wheels_enabled:
            self.drive_target = 0.0
        else:
            self.drive_target = DRIVE_GAIN * (1 if self.forward_pressed else 0) \
                              - DRIVE_GAIN * (1 if self.backward_pressed else 0)

    def _key_cb(self, window, key, scancode, action, mods):
        if key==glfw.KEY_RIGHT:
            if action==glfw.PRESS: self.forward_pressed=True
            elif action==glfw.RELEASE: self.forward_pressed=False
            self._update_drive_target()
        if key==glfw.KEY_LEFT:
            if action==glfw.PRESS: self.backward_pressed=True
            elif action==glfw.RELEASE: self.backward_pressed=False
            self._update_drive_target()

    def close(self):
        self.viewer.close(); self.root.destroy()

if __name__ == '__main__':
    env = BalanceRoverEnv()
    dt = env.model.opt.timestep
    sim_time = 0.0

    while sim_time < SIM_DURATION:
        mujoco.mj_step(env.model, env.data)
        sim_time += dt

        # measure states
        theta     = env.data.qpos[3]      # angle
        theta_dot = env.data.qvel[3]      # angular velocity
        # disturbance observer: simple low-pass of measured torque error
        measured_torque = env.data.qfrc_applied[0] * env.model.actuator_gainprm[0]
        # estimate disturbance
        env.dist_est += dt * (-env.dist_est + measured_torque - env.u_smoothed)

        # outer loop: angle‚Üívelocity setpoint
        vel_sp = env.pid_ang.update(theta, theta_dot, dt,
                                    env.drive_current, (-5,5))
        # inner loop: velocity‚Üítorque
        u_ctrl = env.pid_vel.update(vel_sp - theta_dot, theta_dot, dt,
                                     env.u_smoothed, (-3,3))

        # soft-start / ramp-limit on control command
        max_delta = CMD_RATE_LIMIT * dt
        delta = u_ctrl - env.u_smoothed
        if abs(delta) > max_delta:
            env.u_smoothed += np.sign(delta) * max_delta
        else:
            env.u_smoothed = u_ctrl

        # apply manual drive addition
        err_d = env.drive_target - env.drive_current
        mdx   = DRIVE_RAMP_RATE * dt
        if abs(err_d)>mdx:
            env.drive_current += np.sign(err_d)*mdx
        else:
            env.drive_current = env.drive_target

        # final command includes disturbance compensation
        cmd = (env.u_smoothed + env.dist_est) / 3.0 if env.wheels_enabled else 0.0
        env.data.ctrl[0] = cmd
        env.data.ctrl[1] = cmd

        # update UI
        env.angle_label.config(text=f"Angle = {np.rad2deg(theta):.2f}¬∞")
        env.viewer.sync(); env.root.update()

        if abs(theta) > FALL_THRESH:
            print(f"Fallen at t={sim_time:.3f}s (Œ∏={theta:.3f} rad)")

    print("Simulation finished.")
    input("Press Enter to close‚Ä¶")
    env.close()

--------------------------------------

=== File: /c/Users/User/Documents/Balance_Rover/Controller/run_cpp.py ===
#!/usr/bin/env python3
import subprocess
import sys
import os
import shutil

# If your compiler lives outside the venv, prepend its bin folder here:
EXTRA_PATHS = [
    r"C:\msys64\mingw64\bin", 
    r"C:\MinGW\bin",
    r"C:\TDM-GCC-64\bin"
]
# Update PATH so shutil.which can see g++, clang++, etc.
os.environ["PATH"] = ";".join(EXTRA_PATHS) + ";" + os.environ.get("PATH","")

def find_compiler():
    # 1) Respect CXX env var
    env_comp = os.getenv("CXX")
    if env_comp and shutil.which(env_comp):
        return shutil.which(env_comp)
    # 2) Try common names
    for name in ("g++", "clang++", "c++", "cl"):
        path = shutil.which(name)
        if path:
            return path
    return None

def main():
    if len(sys.argv) != 2:
        print("Usage: python run_cpp.py <cpp_file>")
        sys.exit(1)

    cpp = sys.argv[1]
    if not os.path.isfile(cpp):
        print(f"Error: '{cpp}' not found.")
        sys.exit(1)

    compiler = find_compiler()
    if not compiler:
        print("Error: no C++ compiler found.")
        sys.exit(1)

    # Defaults‚Äîoverride via env vars if needed
    muj_inc = os.getenv("MUJOCO_INCLUDE", r"C:/mujoco/mujoco210/include")
    muj_lib = os.getenv("MUJOCO_LIB",     r"C:/mujoco/mujoco210/bin")
    glf_inc = os.getenv("GLFW_INCLUDE",   r"C:/glfw-3.3.8-mingw-w64/include")
    glf_lib = os.getenv("GLFW_LIB",       r"C:/glfw-3.3.8-mingw-w64/lib-mingw-w64")

    base, _ = os.path.splitext(cpp)
    exe = base + (".exe" if sys.platform.startswith("win") else "")

    # MSVC vs. GCC/Clang flags
    if os.path.basename(compiler).lower().startswith("cl"):
        cmd = [
            compiler, cpp,
            f'/I{muj_inc}', f'/I{glf_inc}', '/EHsc',
            '/link',
            f'/LIBPATH:{muj_lib}', 'mujoco210.lib',
            f'/LIBPATH:{glf_lib}', 'glfw3.lib',
            f'/OUT:{exe}'
        ]
    else:
        cmd = [
            compiler, cpp,
            "-std=c++17", "-O2",
            f"-I{muj_inc}", f"-I{glf_inc}",
            f"-L{muj_lib}", f"-L{glf_lib}",
            "-lmujoco210", "-lglfw3", "-lgdi32",
            "-o", exe
        ]

    print("Compiling with:", compiler)
    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode:
        print("‚ùå Compile error:\n", result.stderr)
        sys.exit(1)

    print("‚úÖ Build succeeded. Running‚Ä¶")
    run = subprocess.run([exe], capture_output=True, text=True)
    if run.returncode:
        print("‚ùå Runtime error:\n", run.stderr)
        sys.exit(1)

    print("üì§ Program output:")
    print(run.stdout)

if __name__ == "__main__":
    main()

--------------------------------------
